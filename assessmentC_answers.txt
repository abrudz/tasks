1.Load the workspace file and save your work in the same workspace file2.A Niladic function is a traditional function which accepts no arguments.However, the descriptions state that the functions "return" a matrix - so MyFunctions and MyVariables do return results.     ∇ fns←MyFunctions[1]    fns←⎕NL 3           ∇                     ∇ vars←MyVariables[1]    vars←⎕NL 2           ∇ 3.heights ← (1,⍴heights)⍴heights4.Simply find the missing number:(+/nvec) - +/nvec[1 3]For example      nvec[1 3]¯3 5      +/nvec12      12 - +/ ¯3 510      nvec ← ¯3 10 55.  ScoresInGroup  ← {(groups=⍵)/scores}ScoresInGroup2 ← {(groups∊⍵)/scores}ScoresInGroup3 ← {scores[i/⍳⍴i←groups=⍵]}ScoresInGroup4 ← {scores[i/⍳⍴i←groups∊⍵]}6. In this workspace, the original functions remain in tact.                   Some functions required use of swap ⍨, but usually at least one could be re-written without swap ⍨.Other functions may have properties which allow different solutions to work.Possible solutions for functions in this workspace are as follows:A.{⍵*⍨-⍺}B.{5-⍨2÷⍨⍴⍵}{¯5+0.5×⍴⍵}C.{¯2+⊃÷/7 ⍵ 9 ⍺*1 7 1 6}   ⍝ For scalar ⍺ and ⍵, no need for ⊃{¯2+⊃7 ⍵ 9 ⍺÷.*1 7 1 6}7.Totals ← {⍵⍪+⌿⍵}8.Cap ← {⍵⌊¯1+⌈/⍵}Cap2 ← {                                     result←⍵                         max←⌈/⍵                          ((result=max)/result)←¯1+max }    Cap3 ← {                                  result←⍵                      max←⌈/⍵                       result[result⍳max]←¯1+max }     ∇  vector←Cap4 vector;max;i       [1]    max←⌈/vector                   [2]    vector[i/⍳⍴i←max=vector]←¯1+max    ∇ 9.YesNo  ← {'YN'[1+⍵<5]}YesNo2 ← {'NY'[1+⍵≥5]}10.CountOver ← {+/⍺∘.<⍵} 11.nmat[2;1] = (+⌿nmat)[1] - nmat[1;1]nmat[1;3] = (+⌿nmat)[3] - nmat[2;3]nmat[1;2] = (+/nmat)[1] - +/nmat[1;1 3]nmat[2;2] = (+/nmat)[2] - +/nmat[2;1 3]For example:      ⍴nmat 2 3       +/nmat 4 ¯14       +⌿nmat ¯19 ¯9 18       nmat[2;3] 5       nmat[1;1] 12       ¯19 - 12¯31      18 - 513      4 - +/12 13¯21      ¯14 - +/¯31 512      nmat ← 2 3⍴12 ¯21 13 ¯31 12 5   12.Index into the alphabet to reveal the words.For example:      ]disp (⊂⎕A)⍳¨words ┌────────────┬──────┐ │8 15 21 19 5│4 15 7│ └────────────┴──────┘      ⎕A[8 15 21 19 5]HOUSE      ⎕A[4 15 7]DOG      words ← 'HOUSE' 'DOG'13.First bug: [5] tries to catenate to short, but short has not been definedFix: Define short←'' on line [3] (insert new line)Second bug: [7] is missing an enclose (⊂)Fix: Add enclose function to line [7] (now [8] if first bug fixed)Edge case: Error occurs if a scalar word is in the listCause: shape function (⍴) returns empty list for scalar wordPossible fixes:- Ravel each word on input   :For word :In ,¨words- Ravel word on shape check   :If 4>⍴,word    :ElseIf 6>⍴,word- Otherwise force the shape check to return 1 for a scalar word (there are many possibilities)   {0=⍴⍴⍵:1⋄⍴⍵}word   {(0=⍴⍴⍵)+1⍴⍴⍵}word14.- Tie the filetn ← 'path\to\customer_your_name.dcf' ⎕FTIE 0- Read the purchase matrix (component 2) and do row-wise sumpmat ← +/⎕FREAD tn 2- Append the row-wise sum of purchase matrix to file(+/pmat) ⎕FAPPEND tn     OR(+/⎕FREAD tn 2) ⎕FAPPEND tn- Find the ID of customer who had the highest total, either using APL or by inspectionids ← ⎕FREAD tn 1max_id ← (totals=⌈/totals←+/pmat)⌿ids- Append the ID of customer who had the highest total to the filemax_id ⎕FAPPEND tn- Untie the file (automatically untied when Dyalog closes)⎕FUNTIE tn
